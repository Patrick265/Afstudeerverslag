\chapter{Uitvoering NOT DONE}
In dit hoofdstuk wordt de uitvoering en het process beschreven van het afstudeeropdracht. Het project kan opgesplitst worden in een paar grote onderdelen. De uitvoering zal dan ook opgesplitst worden in de volgende fases. Ten eerste wordt er gekeken naar structuur, interfacing, communicatie, sensoren en uiteindelijk transformatie/filters. In deze volgorde is dan ook de applicatie ontwikkeld.

\section{Overzicht}
Om een beeld te krijgen wat er gedaan is in de laatste 20 weken tijdens het afstuderen is er een overzicht gemaakt van welke grootte taken er ontwikkeld zijn. Het diagram laat zien wat er ontwikkeld/ontworpen is en welke stappen hij daarvoor genomen heeft om deze taak goed af te ronden. Er zijn hiervoor een paar fases type gekozen, ten eerste zal er gekeken worden naar het ontwerp, interface, sensor data en communicatie.

\begin{table}[h!]
	\centering
	\caption{Fases van de uitvoering}
	\label{tab:UitvoeringOverzicht}
	\begin{tabular}{lp{13cm}}
	\toprule
	\textbf{Fase} & \textbf{Samenvatting} \\ \midrule
	Ontwerp & In deze fase is onderzoek gedaan naar generiek software ontwerp en de payload structuur voor de CAN communicatie. Daarnaast is er ook gekeken naar het hardware validatie. \\
	Interface & In de interface fase is er test en debug applicatie ontworpen voor de applicatie en de hardwarevalidatie onderdeel. \\
	Communicatie & Hier wordt er gekeken naar de UDP communicatie en CAN BUS communicatie.                      \\
	Sensors  & Hier wordt er gekeken hoe er verschillende sensoren uitgelezen kunnen worden via verschillende protocollen.                      \\ 
	Transformatie en filter & In deze fase wordt er gekeken hoe de data geprocesed wordt. \\ \bottomrule
	\end{tabular}
\end{table}

\newpage
\section{Ontwerp}
Het ontwerp van de applicatie is het belangrijkste onderdeel van de applicatie, dit beantwoord namelijk de hoofdvraag en twee deelvragen. Dit moet dan ook goed onderzocht worden, zodat in toekomst Sensor Maritime veel sensoren kan ondersteunen zonder grotere aanpassing aan de applicatie. Dat is het uiteindelijk doel van het ontwerp hoe kan er met minimale verandering aan de applicatie nieuwe sensoren toegevoegd worden. Met het ontwerp kunnen de volgende fases gebouwd worden op basis van het bedachte structuur. Het ontwerp is een groot onderdeel en combinatie van verschillende onderdelen van de applicatie en dit zal dan ook in dit hoofdstuk opgesplitst worden in verschillende onderdelen.

\subsection{Applicatie}
Om het structuur op te zetten moest er gekeken worden naar welke programmeertaal er gebruikt gaat worden. Dit was dan ook de eerste taak die student op zich nam. Omdat dit goed te kiezen moet er een analyses gemaakt worden op, wat gebruikt Sensor Maritime standaard. Daarnaast moet erook gekeken worden bestaan er software ontwerpen/design patterns die een generieke structuur creeëren. De programmeertaal keuze was met de stagebegeleider besproken waarbij, er twee opties onstaan zijn. De twee opties waren C of C++, Sensor Maritime gebruikt standaard voor de embedded producten C. Sensor Maritime had minder ervaring met C++. Met deze informatie is de stagair gaan kijken naar hoe de structuur zou opgebouwd kan worden in zowel C als in C++. Met C++ zal er meer abstractie gemaakt kunnen worden omdat je dan werkt met object georienteerd programmeren. Alleen zullen de bestaande lagen van de applicatie structuur bestaan. De toegevoegde waarden van C++ had niet genoeg impact om het te gebruiken. \newline

\noindent Met de taal gekozen is een software abstractie gemaakt waardoor zo veel mogelijk generiek is. Dit is aan de hand van de applicatie lagen en de preprocessor gedaan. Met de applicatie lagen kan er aanpassingen of toevoegingen gemaakt worden aan de applicatie zonder dat de applicatie logica veranderd hoeft te worden. De preprocessor zorgt er voor dat er gemakkelijk functionaliteiten en sensoren aan of uit gezet kan worden. Met de preprocessor kan er bijvoorbeeld makkelijk gekozen worden welke versie sensor er gebruikt moet worden. De overige sensoren worden dan ook niet mee gecompileerd.

\subsection{CAN}
Het volgende onderdeel van het structuur is de communicatie via de CAN BUS. Hiervoor is al een bestaand protocol die door Sensor Maritime is ontworpen. Het probleem van dit protocol is dat het niet ontwikkeld is voor eindsystemen met verschillende sensoren. Er wordt nu er van uitgegaan dat de payload van het packet, maar een sensor data heeft. Terwijl de Satellite veel meer dan een sensor aanbord kan hebben. Dus het hoofdsysteem die de sensor data wil weet dan niet wat voor sensor data hij ontvangt, is het 1 of 2 sensoren en welke sensoren zijn het dan. Hier moest een systeem bedacht voor worden. Hiervoor zijn drie ontwerpen gemaakt. Een simpel structuur, een generiek modulair structuur en een structuur wat er tussen zit. Dit is voorgelegd bij het stagebedrijf, hierover is gediscussieerd wat het meest optimale structuur is voor zowel het eindsysteem als de Satellite. Uit deze discussie is de structuur gekozen was er tussen in zit.

\subsection{Hardware validatie}
Een van de taken die Sensor Maritime mij heeft opgelegd is om een systeem te bedenken, zodat als Sensor Maritime nieuw Satellite hardware hebben dat ze die makkelijk kunnen testen. De onderdelen die getest moeten worden zijn IO porten de Satellite. Het manier van testen en wat getest moet worden is als eerst besproken met de stagebegeleider. Hiervoor is een testplan ontwikkeld dat voor elke IO port een manier van testen heeft. Aan de hand van de testplan is er een test applicatie geschreven wat de applicatie test aan de hand wat er beschreven is bij het testplan. Om alle firmware die voor de Satellite is ontwikkeld is de Satellite applicatie en test applicatie samengevoegd. Hiervoor is de preprocessor gebruikt. Sensor Maritime hoeft alleen maar een definitie uit of aan te zetten en opnieuw compileren. Hiermee kan Sensor Maritime makkelijk wisselen tussen hardware validatie en echte Satellite applicatie.

\section{Interface}
Om de uiteindelijk Satellite applicatie, en testplan applicatie te kunnen testen zal er een applicatie nodig zijn die kijkt of de hardware applicatie wel werken na toebehoren. Hiervoor zijn twee desktop applicaties gemaakt. Deze twee applicaties zullen opgesplitst worden in subhoofdstukken die hieronder beschreven zijn.

\subsection{Satellite debug applicatie}
De debug applicatie is geschreven om te testen of de functionaliteiten van de applicatie werken. Dit geeft de ontwikkelaar een beeld of de verwachte data kloppend is. De Satellite communiceert met de debug applicatie via UDP, hiervoor is gekozen aangezien de klant het uiteindelijk zo verwacht. De debug applicatie moet dan ook een simulatie zijn van wat de klant verwacht te ontvangen.

\subsection{Testplan applicatie}
De testplan applicatie is ontwikkeld om sommige onderdelen van de testplan te testen. Serieele communicatie is lastig om te verifiëren zonder een desktop applicatie. Het doel van de testplan applicatie is dat Sensor Maritime snel kan zien of de hardware werkt zoals verwacht.

\section{Communicatie}
Het communicatie is een groot onderdeel van de applicatie. Vanuit Satellite moet er gecommuniceerd worden met een eindsysteem. Tijdens de implementatie van de applicatie zijn verschillende vormen van communicatie gebruikt met het eindsysteem. Deze twee vormen van communicatie zijn bepaald door de klant. \newline

\noindent De eerste vorm van communicatie die ontwikkeld is de UDP. Via UDP communicatie wordt verschillende sensor data opgestuurd om de seconden. Voor elke sensor wordt een apart packet opgestuurd hiervoor is een standaard structuur voor bedacht. Ten eerste wordt alle data opgestuurd in bytes. vervolgens wordt er een prefix toegevoegd met maximaal acht bytes, bijvoorbeeld \textit{imu,}. Met deze prefix weet het eindsysteem wat voor data ontvangen kan worden. Vervolgens wordt er een sensor speciek payload opgestuurd. De payload structuur is gespecifeerd met de klant en is per sensor verschillend. \newline

\noindent De twee vorm van communicatie gaat via CAN BUS. Dit wordt alleen gebruikt om te kunnen communiceren met het hoofdsysteem. Het hoofdsysteem kan verschillende dingen vragen aan de Satellite en dit moet allemaal afgehandeld worden. Bijvoorbeeld het hoofdsysteem kan de status opvragen van de Satellite. Zodra de Satellite dit ontvangt moet het ontvangen packet opgebouwd worden en gecheckt zijn of het ontvangen packet ook echt is wat er opgestuurd is door het hoofdsysteem. Als dat gedaan moet er gekeken worden wat vraagt het hoofdsysteem aan de Satellite. Hiervoor zijn verschillende states gemaakt die op elke type bericht een antwoord kan geven. Dus als de hoofdsysteem de status opvraagt van de Satellite zal de Satellite zijn status terugsturen.


\section{Sensors}
De volgende fase was om voor de sensoren een abstractie en driver laag ontwikkelen. De abstractie laag zal bepalen hoe de sensor zich moet gedragen. De abstractie laag is het tussenpersoon van de applicatie logica en sensor drivers. Het idee is dan ook dat de abstractie laag met de hulp van preprocessor bepaald welke sensor gebruikt gaat worden. Voor elke sensor is een nieuwe definitie toegevoegd wat bepaald of de sensor abstractie laag de sensor driver aanroept of niet. Er zijn verschillende type sensoren, sommige sensoren werken via SPI, serieel of juist analoog. Dit wordt allemaal uitgewerkt in de sensor driver. Elke sensor is anders in werking, dus drivers zal altijd toegevoegd worden.

\section{Transformatie en filters}
Dit onderdeel gebeurt nadat de sensor data is opgehaald. Bepaalde data moet verwerkt worden, zodat de klant iets heeft aan de data die laten zien wordt. Op het moment wordt er maar op een sensor deze transformatie/filter toegevoegd, dit is op inertial measurement unit (imu). De imu bestaat uit twee onderdelen, ten eerste is een versnellingsmeter aan boord. De Versnellingsmeter meet de versnelling in de x, y en z axis. Daarnaast bezit de imu ook een gyroscoop wat de hoekversnelling per seconde geeft. Met de imu kan je ook de hoek berekenen, de componenten los hebben beide problemen. De versnellingsmeter heeft veel ruis en kan af en toe verspringen. De gyroscoop is alleen accuraat in het begin, naar mate de tijd vordert zal de waarde langzaam wegdriften. Los zijn de componenten niet goed genoeg om een accurate hoekmeting te krijgen, maar als beide componenten samengevoegd wordt los je beide problemen op. Om de twee componenten samen te voegen zal er gebruikt gemaakt worden van een filter. Hiervoor is de complimentary filter gebruikt. De complimentary filter zegt dat je een percentage van de gyroscoop en een percentage van de versnellingsmeter moet nemen, dit moet samen 100\% zijn. De wiskundige notatie gaat als volgt \ref{eqn:compfilter}, hierbij worden een aantal variable gebruikt. De eerste variable is $\alpha$, dit geeft aan hoeveel procent je van de gyroscoop wil, in de huidige implementatie is hiervoor $0,02$ gebruikt. Dit betekent dat er $98\%$ gebruikt wordt van de gyroscoop en $2\%$ van de versnellingsmeter. Vervolgens wordt de vorige hoek gepakt en dit wordt toegevoegd aan de huidige gyroscoop waarden wat vervolgens vermenigvuldigd wordt door de frequency. Uiteindelijk wordt de versnellingsmeter toegevoegd.

\begin{equation}
\label{eqn:compfilter}
	\begin{array}{l}
	roll[t] = (1 - \alpha) * (roll[t - 1] + G_{x} * \Delta t) + \alpha * A_{roll} \\
	pitch[t] = (1 - \alpha) * (pitch[t - 1] + G_{y} * \Delta t) + \alpha * A_{pitch} \\ 
	yaw[t] = (1 - \alpha) * (yaw[t - 1] + G_{z} * \Delta t) + \alpha * A_{yaw} 
\end{array}
\end{equation}