\chapter{Ontwerp}
In dit hoofdstuk wordt er gekeken naar het softwareontwerp, er wordt gefocust om een robuust en generiek applicatie en communicatie ontwikkelen. De applicatie is op het moment opgebouwd in verschillende onderdelen, deze onderdelen zijn de applicatie, preprocessor, sensor drivers en abstractie en communicatie.

\section{Structuur}
Voor dat er gekeken kan worden naar het ontwerp moet er een overzicht gemaakt worden hoe de applicatie uiteindelijk zich moet gaan gedragen. Hoe moet er gecommuniceerd worden, hoe kiest de applicatie welke sensor hij aan het uitlezen is dit. De volgende afbeelding geeft \ref{fig:appstructuur} geeft dit overzicht. 
\begin{figure}[h!]
	\centering
	\label{fig:appstructuur}

	\includegraphics[width=1\linewidth]{ontwerp/compleet structuur.png}
	\caption{Algemene structuur van de applicatie}
\end{figure}

\newpage
\section{Applicatie}
De applicatie moet zo generiek mogelijk zijn, dit betekent dat de applicatie moet werken als er bijvoorbeeld van sensor verandert of toegevoegd wordt. Als er nieuwe sensor toegevoegd wordt is er een doel, het doel is dat de enige toevoeging wat er gemaakt moet worden is dat er een driver geschreven wordt voor dat specifieke sensor, maar aanpassing aan de applicatie moet minimaal gebeuren. In afbeelding \ref{fig:appontwerp} wordt een algemeen overzicht gemaakt hoe de applicatie in lagen is opgebouwd. 
\begin{figure}[h!]
	\centering
	\label{fig:appontwerp}

	\includegraphics[width=1\linewidth]{ontwerp/applicatie/structuur.jpg}
	\caption{De applicatie ontwerp in lagen}
\end{figure}



\subsection{Applicatie states}
De applicatie is zo ontworpen dat er gebruikt gemaakt wordt van verschillende states en taken die om de bepaalde tijd uitgevoerd moet worden. Deze states zijn tijdvariant maar sommige states zijn juist weer tijdsinvariant. Een tijdvariant taak  betekent dat om zoveel milliseconden er een taak uitgevoerd zal worden. In het ontworpen systeem wordt er om de 100 ms een akkoord gegeven aan de applicatie om sensor data op te halen en uiteindelijk opgestuurd te worden. Een belangrijk onderdeel van de applicatie is de communicatie, het is ontworpen dat er om de seconden sensor data opgestuurd wordt via UDP. Een tijdsinvariant taken zijn taken die niet op tijd gebaseerd zijn. De GNSS Sensor stuurt bijvoorbeeld continue data op. Dit betekent dat er verschillende taken zijn die uiteindelijke allemaal samengevoegd moet worden, hieronder is te zien \ref{fig:appstates} hoe de applicatie dit oplost. \newline

\begin{figure}[h!]
	\centering
	\label{fig:appstates}

	\includegraphics[width=0.73\linewidth]{ontwerp/applicatie/ApplicationStates.jpg}
	\caption{Applicatie states van de applicatie}
\end{figure}

\noindent In het figuur \ref{fig:appstates} zijn er een aantal start nodes, ten eerste is de tijdsvariant onderdeel. Dit wordt per 100 milliseconden uitgevoerd, er wordt hier alleen gecheckt of de applicatie sensor data mag ophalen of verzenden. De applicatie krijgt om de 100 milliseconden dus de tijd om een signaal te geven aan de applicatie loop dat het tijdvariant sensor data opgehaald mag worden. Er mag pas data opgestuurd worden als een bepaald tijdsinterval gehaald wordt, het ontworpen systeem zal dit om 1 seconden doen. Dit betekent voor 10 timer cycles mag er een keer data opgestuurd worden. Bij de 10de cycle wordt er weer signaal gegeven aan de applicatie loop dat er data opgestuurd mag worden. \newline

\noindent Naast het tijdsvariant onderdeel is er ook een tijdsinvariant onderdeel. Dit wordt gebruikt voor sensoren die bijvoorbeeld continue data opsturen naar de Satellite. Dit onderdeel slaat alleen data en als het een compleet sensor packet heeft dan geeft het een signaal aan de applicatie dat er een sensor packet verstuurd kan worden. \newline

\noindent Het laatste onderdeel is de applicatie loop, hier wordt de tijdvariant sensor data opgehaald en uiteindelijk opgestuurd. Er wordt als eerst gecheckt of er een akkoord is om sensor data op te halen of te versturen, als die er is dan haalt hij de tijdsvariant data op, en vervolgens wordt er gekeken of er een tijdsinvariant sensor packet klaar staat. Als dat is wordt het tijdsinvariant packet opgehaald en samengevoegd, en opgestuurd via UDP. Mocht dit niet zijn dan wordt alleen het tijdsvariant sensor data opgehaald en gelijk opgestuurd. \newline

\section{Preprocessor} \label{sec:preprocessor}
De preprocessor is een handig onderdeel van de C taal en een belangrijk onderdeel van het project. De preprocessor is een stap wat voor het compileren gebeurt wordt. Met bepaalde definities in de code kunnen sommige onderdelen niet gecompileerd worden of juist wel. Dit betekent dat makkelijk onderdelen uitgezet kan worden, bijvoorbeeld een specifieke sensor hoeft niet gebruikt te worden, normale wijze zou je dan een if statement maken. Dit betekent alleen wel dat alle code mee gecompileerd zou worden. Met de preprocessor voeg je weer een if statement toe maar dan hoeft de code niet aangepast te worden, er hoeft alleen maar definitie verwijderd worden of toegevoegd worden. Dit betekent dat hele stuk logica niet weggehaald hoeft te worden, de preprocessor bepaald dan of bepaalde onderdelen gecompileerd worden of niet, dit verminderd de compilatie tijd en de uiteindelijk grootte van het programma \autocite{preprocessor}. 

\section{Sensor drivers en abstractie}
Voor de sensoren zijn er twee lagen ontwikkeld, namelijk de drivers en de abstractie. Dit is opgesplitst om de software zo generiek mogelijk te maken. Er wordt dan ook hier naar de volgende deelvraag bekeken \textbf{Op welke manier moet de software ontworpen worden zodat het makkelijk uitbreidbaar is voor nieuwe sensoren?} \newline 

\noindent De drivers en abstractie zijn opgesplitst zodat de applicatie structuur niet aangepast hoeft te worden, er zal dan alleen een nieuwe driver geschreven moeten worden en de abstractie aangepast moeten worden. De driver communiceert met de sensor, en de abstractie is de tussenpersoon tussen applicatie logica en driver. De applicatie zal dan niet veranderen. Om een voorbeeld te geven, de applicatie heeft een poll timer. Deze timer haalt om de 100 milliseconden data op van de inertial measurement unit. Mocht Sensor Maritime een nieuwe inertial measurement unit ondersteunen, normaal zou dan de applicatie logica ook aangepast moeten worden met bepaalde sensor drivers functies. De sensor abstractie vervangt dit het idee is dan ook dat in toekomst de applicatie laag code zo min mogelijk aangepast moet worden. De sensor abstractie moet dan juist aangepast worden en de applicatie laag roept dan de sensor abstractie code op. Hieronder is een overzicht \ref{fig:SensorAbstractie} te zien hoe het dan zou werken. De sensor keuze wordt makkelijk gedaan met de preprocessor (zie hoofdstuk \ref{sec:preprocessor}), hiermee worden sommige sensoren niet gecompileerd of juist wel.
\begin{figure}[h!]
	\centering
	\label{fig:SensorAbstractie}

	\includegraphics[width=0.46\linewidth]{ontwerp/applicatie/SensorAbstractie.jpg}
	\caption{Sensor abstractie activity diagram}
\end{figure}
	
	
\newpage
\section{Communicatie}
\input{chapters/ontwerp/communicatie.tex}
\newpage

\newpage
\section{Validatie}
\input{chapters/ontwerp/hardwarevalidatie.tex}

\newpage
\section{Klasse diagram}
Hieronder is een klasse diagram gegeven van de hele applicatie \ref{fig:klassediagram}. In de klasse diagram is goed is te zien dat alle sensoren een abstractie laag hebben, die specifieke gekoppeld is aan een sensor  driver. De hardware abstractie lagen die door DAVE zijn gemaakt zijn worden niet getoond in de klasse diagram aangezien dit een externe library is.
\begin{figure}[h!]
	\centering
	\label{fig:klassediagram}

	\includegraphics[width=\linewidth]{ontwerp/applicatie/Satellite.jpg}
	\caption{Algemene structuur van de applicatie}
\end{figure}
